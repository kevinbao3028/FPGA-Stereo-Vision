
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE1_SOC(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output	reg	     [6:0]		HEX0,
	output	reg	     [6:0]		HEX1,
	output	reg	     [6:0]		HEX2,
	output	reg	     [6:0]		HEX3,
	output	reg	     [6:0]		HEX4,
	output	reg	     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// PS2 //////////
	inout 		          		ps2_clk,
	inout 		          		ps2_clk2,
	inout 		          		ps2_data,
	inout 		          		ps2_data2,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output reg		          		VGA_BLANK_N,
	output reg		     [7:0]		VGA_B,
	output 			          		VGA_CLK,
	output reg		     [7:0]		VGA_G,
	output reg	 	         		VGA_HS,
	output reg		     [7:0]		VGA_R,
	output 			          		VGA_SYNC_N,
	output reg			       		VGA_VS,

	//////////// GPIO_0, GPIO_0 connect to D8M-GPIO //////////
	inout 		          		aCAMERA_I2C_SCL,
	inout 		          		aCAMERA_I2C_SDA,
	output		          		aCAMERA_PWDN_n,
	output		          		aMIPI_CS_n,
	inout 		          		aMIPI_I2C_SCL,
	inout 		          		aMIPI_I2C_SDA,
	output		          		aMIPI_MCLK,
	input 		          		aMIPI_PIXEL_CLK,
	input 		     [9:0]		aMIPI_PIXEL_D,
	input 		          		aMIPI_PIXEL_HS,
	input 		          		aMIPI_PIXEL_VS,
	output		          		aMIPI_REFCLK,
	output		          		aMIPI_RESET_n,

	//////////// GPIO_1, GPIO_1 connect to D8M-GPIO //////////
	inout 		          		bCAMERA_I2C_SCL,
	inout 		          		bCAMERA_I2C_SDA,
	output		          		bCAMERA_PWDN_n,
	output		          		bMIPI_CS_n,
	inout 		          		bMIPI_I2C_SCL,
	inout 		          		bMIPI_I2C_SDA,
	output		          		bMIPI_MCLK,
	input 		          		bMIPI_PIXEL_CLK,
	input 		     [9:0]		bMIPI_PIXEL_D,
	input 		          		bMIPI_PIXEL_HS,
	input 		          		bMIPI_PIXEL_VS,
	output		          		bMIPI_REFCLK,
	output		          		bMIPI_RESET_n
);


//=============================================================================
// reg and wire declarations
//=============================================================================
   wire           orequest;
	
	reg [7:0] test;
	
	
   wire           VGA_CLK_25M;
   wire           RESET_N; 
   wire    [7:0]  bsCCD_R;
   wire    [7:0]  bsCCD_G;
   wire    [7:0]  bsCCD_B; 
   wire   [12:0]  bx_count,bcol; 
   wire   [12:0]  by_count,brow; 
   wire           bI2C_RELEASE;  
   wire           bCAMERA_I2C_SCL_MIPI; 
   wire           bCAMERA_I2C_SCL_AF;
   wire           bCAMERA_MIPI_RELAESE;
   wire           bMIPI_BRIDGE_RELEASE;
	
   wire    [7:0]  asCCD_R;
   wire    [7:0]  asCCD_G;
   wire    [7:0]  asCCD_B; 
   wire   [12:0]  ax_count,acol; 
   wire   [12:0]  ay_count,arow; 
   wire           aI2C_RELEASE;  
   wire           aCAMERA_I2C_SCL_MIPI; 
   wire           aCAMERA_I2C_SCL_AF;
   wire           aCAMERA_MIPI_RELAESE;
   wire           aMIPI_BRIDGE_RELEASE;

	
	wire				MIPI_REFCLOCK;
		assign bMIPI_REFCLK = MIPI_REFCLK;	
		assign aMIPI_REFCLK = MIPI_REFCLK;
		
	wire	[7:0]		VGA_R_c,
						VGA_G_c,
						VGA_B_c;
	wire				VGA_HS_c,
						VGA_VS_c,
						VGA_BLANK_N_c;
//=======================================================
// Main body of code
//=======================================================


assign RESET_N= ~SW[0]; 

assign bMIPI_RESET_n   = RESET_N;
assign bCAMERA_PWDN_n  = RESET_N; 
assign bMIPI_CS_n      = 1'b0; 

assign aMIPI_RESET_n   = RESET_N;
assign aCAMERA_PWDN_n  = RESET_N; 
assign aMIPI_CS_n      = 1'b0; 

assign VGA_CLK = aMIPI_PIXEL_CLK;
assign VGA_SYNC_N 	= 1'b0;

//assign  HEX0[0] = KEY[3];



//VGA output register clocking
always @(posedge VGA_CLK) begin
	VGA_HS		<=	VGA_HS_c			;
	VGA_VS		<=	VGA_VS_c			;
	VGA_BLANK_N	<=	VGA_BLANK_N_c	;
	VGA_R			<=	orequest ? VGA_R_c : 8'h00;
	VGA_G			<=	orequest ? VGA_G_c : 8'h00;
	VGA_B			<=	orequest ? VGA_B_c : 8'h00;
end
//------ MIPI BRIDGE  I2C SETTING--------------- 
MIPI_BRIDGE_CAMERA_Config bcfin(
   .RESET_N           ( RESET_N ), 
   .CLK_50            ( CLOCK_50), 
   .MIPI_I2C_SCL      ( bMIPI_I2C_SCL ), 
   .MIPI_I2C_SDA      ( bMIPI_I2C_SDA ), 
   .MIPI_I2C_RELEASE  ( bMIPI_BRIDGE_RELEASE ),
   .CAMERA_I2C_SCL    ( bCAMERA_I2C_SCL ),
   .CAMERA_I2C_SDA    ( bCAMERA_I2C_SDA ),
   .CAMERA_I2C_RELAESE( bCAMERA_MIPI_RELAESE )
);
MIPI_BRIDGE_CAMERA_Config acfin(
   .RESET_N           ( RESET_N ), 
   .CLK_50            ( CLOCK_50), 
   .MIPI_I2C_SCL      ( aMIPI_I2C_SCL ), 
   .MIPI_I2C_SDA      ( aMIPI_I2C_SDA ), 
   .MIPI_I2C_RELEASE  ( aMIPI_BRIDGE_RELEASE ),
   .CAMERA_I2C_SCL    ( aCAMERA_I2C_SCL ),
   .CAMERA_I2C_SDA    ( aCAMERA_I2C_SDA ),
   .CAMERA_I2C_RELAESE( aCAMERA_MIPI_RELAESE )
);
//-- MIPI CLK PLL --- 
video_pll2 MIPI_clk(
	.ref_clk_clk	(CLOCK_50),
	.ref_reset_reset(1'b0),
	.video_in_clk_clk(MIPI_REFCLK)
);
RAWDATA_TO_RGB rawtorgb(
	.RST_N( RESET_N ),
	
	.aData( aMIPI_PIXEL_D ),
	.aHS	( aMIPI_PIXEL_HS ),
	.aVS	( aMIPI_PIXEL_VS ),
	.aClk	( aMIPI_PIXEL_CLK ),
	
	.bData( bMIPI_PIXEL_D ),
	.bHS	( bMIPI_PIXEL_HS ),
	.bVS	( bMIPI_PIXEL_VS ),
	.bClk	( bMIPI_PIXEL_CLK ),
	
	.aR	( raw_aR ),
	.aG	( raw_aG ),
	.aB	( raw_aB ),
	.bR	( raw_bR ),
	.bG	( raw_bG ),
	.bB	( raw_bB ),
	
	.rdClk( VGA_CLK ),
	.oX	( x1 ),
	.oY	( y1 ),
	
	.swtest(SW[1])
);

RGB_Process p1 (
   .a_R(raw_aR),
   .a_G(raw_aG),
   .a_B(raw_aB),
	.b_R(raw_bR),
   .b_G(raw_bG),
   .b_B(raw_bB),
	.a_Gray(aGray),
	.b_Gray(bGray),
	.a_csct(a_postcsct),
	.b_csct(b_postcsct),
	.disp(argmin),
	.min(min),
   .y      (y4),
   .x      (x4),
   .o_VGA_R  (VGA_R_c), //modify these values to change the color
   .o_VGA_G  (VGA_G_c),
   .o_VGA_B  (VGA_B_c),
   .LEDR         (LEDR[9:0]),
   .HEX0         (HEX0),
   .HEX1         (HEX1),
   .HEX2         (HEX2),
   .HEX3         (HEX3),
   .HEX4         (HEX4),
   .HEX5         (HEX5),
   .ps_clk     (ps2_clk),
   .ps_data     (ps2_data),
   .switch     (SW[9:1]),
   .KEY         (KEY[3:0]),
   .CLOCK_50 (CLOCK_50),
   .CLOCK_25 (VGA_CLK)
);

wire [7:0] raw_aR,raw_aG,raw_aB, raw_bR,raw_bG,raw_bB,	aGray,bGray,	aRect,bRect;
wire [12:0] x1,x2,y1,y2,x3,y3,x4,y4,x5,y5;
//cyan		000	255	255
//magenta	255	000	255
//yellow		255	255	000
assign aGray 			= (raw_aR+raw_aG+raw_aG+raw_aB+10'b0)>>2;
assign bGray 			= (raw_bR+raw_bG+raw_bG+raw_bB+10'b0)>>2;
//assign VGA_R_c			= SW[1] ? raw_aR : raw_bR;//aGray;
//assign VGA_G_c 		= SW[1] ? raw_aG : raw_bG;//(aGray+bGray)>>1;
//assign VGA_B_c 		= SW[1] ? raw_aB : raw_bB;//bGray;
assign VGA_HS_c		= ~( (x4>=652)&(x4<=747) );//655-750		652-747
assign VGA_VS_c		= ~( (y4>=13)&(y4<=14) );//start at 45	491-492	(11-12)
assign orequest		=	(x4<640)&&(y4>=45);	//REMINDER: put back at x2,y2
assign VGA_BLANK_N_c	= (VGA_HS_c&VGA_VS_c);
//TODO: test with highpass first to get some illumination indifference
wire [23:0]	a_postcsct,b_postcsct,a_posthighpass,b_posthighpass;

//assign VGA_R_c	= SW[2] ? (SW[1]?raw_aR:raw_bR) : atemp;//SW[1] ? aGray : 2*(raw_aR)>(raw_aR+2*raw_aG+raw_aB) ? 8'hFF : 8'h00;
//assign VGA_G_c = SW[2] ? (SW[1]?raw_aG:raw_bG) : 8'h00;
//assign VGA_B_c	= SW[2] ? (SW[1]?raw_aB:raw_bB) : btemp;//SW[1] ? bGray : 2*(raw_bR)>(raw_bR+2*raw_bG+raw_bB) ? 8'hFF : 8'h00;
//wire	[7:0]	atemp,btemp;
//SOBELMAG aredsobel(
//	.clk(VGA_CLK),	//pixel speed clock (25MHz)
//	.pix(raw_aR),
//	.row(y1),
//	.col(x1),
//	.pixout(atemp),
//	.rowout(y2),
//	.colout(x2)
//);
//SOBELMAG bredsobel(
//	.clk(VGA_CLK),	//pixel speed clock (25MHz)
//	.pix(raw_bR),
//	.row(y1),
//	.col(x1),
//	.pixout(btemp)
//);
//
wire [7:0] aP,bP;
assign aP = aGray;//(y1[6:0]==8'h7F)||(x1[6:0]==8'h7F) ? 8'hFF : aGray;
assign bP = bGray;
RECTIFY rectifier(
	.clk(VGA_CLK),
	.a(aP),
	.b(bP),
	.ix(x1),
	.iy(y1),
	.ox(x2),
	.oy(y2),
	.oa(aRect),
	.ob(bRect)
);
//assign x2 = x1;
//assign y2 = y1;
HIGHPASS ahighpass(
	.clk(VGA_CLK),	//pixel speed clock (25MHz)
	.pix(aGray),
	.row(y2),
	.col(x2),
	.pixout(a_posthighpass),
	.rowout(y3),
	.colout(x3)
);
HIGHPASS bhighpass(
	.clk(VGA_CLK),	//pixel speed clock (25MHz)
	.pix(bGray),
	.row(y2),
	.col(x2),
	.pixout(b_posthighpass),
);
CSCT acsct(
	.clk(VGA_CLK),	//pixel speed clock (25MHz)
	.pix(aGray),
	.row(y3),
	.col(x3),
	.pixout(a_postcsct),
	.rowout(y4),
	.colout(x4)
);
CSCT bcsct(
	.clk(VGA_CLK),	//pixel speed clock (25MHz)
	.pix(bGray),
	.row(y3),
	.col(x3),
	.pixout(b_postcsct)
);
wire [7:0] min,argmin;
DISPARITY disparity(
	.clk(VGA_CLK),
	.a(a_postcsct),
	.b(b_postcsct),
	.aGrad(agrad),
	.x(x4),
	.y(y4),
	.oreq(orequest),
	.omin(min),
	.oargmin(argmin),
	.ox(x5),
	.oy(y5)
); 

SOBELMAG bsobel(
	.clk(VGA_CLK),	//pixel speed clock (25MHz)
	.pix(bRect),
	.row(y4),
	.col(x4),
	.pixout(bgrad)
);
SOBELMAG asobel(
	.clk(VGA_CLK),	//pixel speed clock (25MHz)
	.pix(aRect),
	.row(y4),
	.col(x4),
	.pixout(agrad)
);

HYBRIDMEDIANBLUR outblur(
	.clk(VGA_CLK),	//pixel speed clock (25MHz)
	.pix(argmin),
	.row(y4),
	.col(x4),
	.pixout(filt)
);
wire [7:0]	agrad,bgrad,filt;
//assign VGA_R_c = a_posthighpass;//SW[6] ? filt : SW[5] ? (SW[1]?agrad:bgrad) : SW[4] ? (SW[1]?a_postcsct[7:0]:b_postcsct[7:0]): SW[3] ? (min<64?argmin<<2:8'h00) : (SW[2] ? (SW[1] ? a_posthighpass : b_posthighpass) : (SW[1] ? argmin<<2 : min<<3));//a_postcsct^b_postcsct;
//assign VGA_G_c = a_peak||b_peak ? 8'hFF : 8'h00;//SW[6] ? filt : SW[5] ? (SW[1]?agrad:bgrad) : SW[4] ? (SW[1]?a_postcsct[15:8]:b_postcsct[15:8]) : VGA_R_c;
//assign VGA_B_c = b_posthighpass;//SW[6] ? filt : SW[5] ? (SW[1]?agrad:bgrad) : SW[4] ? (SW[1]?a_postcsct[23:16]:b_postcsct[23:16]) : VGA_R_c;

//assign VGA_R_c = aRect;
//assign VGA_G_c = 8'h00;
//assign VGA_B_c = bRect;

////assign VGA_B_c = bDelay[8*SW[9:1] +:8];
////assign VGA_G_c = 8'h00;
////assign VGA_R_c = aGray;
////assign {VGA_R_c,VGA_G_c,VGA_B_c} = SW[2] ? (SW[1] ? aGray : bGray) : (SW[1] ? a_postcsct : b_postcsct);
wire signed [7:0] xgrad,ygrad,corn;
//SOBEL asobel(
//	.clk(VGA_CLK),	//pixel speed clock (25MHz)
//	.pix(SW[1] ? aGray : bGray),
//	.row(y1),
//	.col(x1),
//	.xgrad(xgrad),
//	.ygrad(ygrad),
//	.rowout(y2),
//	.colout(x2)
//);
//CORNER acorn(
//	.clk(VGA_CLK),
//	.xgrad(xgrad),
//	.ygrad(ygrad),
//	.col(x2),
//	.row(y2),
//	.pixout(corn),
//	.ocol(x3),
//	.orow(y3)
//);
////.en(~KEY0),//BEWARE: active high or active low
//PEAKS apeak(
//	.clk(VGA_CLK),
//	.en(SW[9]),
//	.rst(SW[8]),
//	.pix(aGray),
//	.corner(corn),
//	.col(x2),
//	.row(y2),
//	.pixout(peak)
//);	//BEWARE: signed underflow for gradients
//assign VGA_R_c = SW[5] ? aGray : peak ? 8'hFF : SW[4] ? aGray : SW[3] ? corn : SW[2]?(xgrad+8'd128):(ygrad+8'd128);	
//assign VGA_G_c = SW[5] ? 8'h0  : peak ? 8'h00 :	SW[4] ? aGray : SW[3] ? corn : SW[2]?(xgrad+8'd128):(ygrad+8'd128);
//assign VGA_B_c = SW[5] ? bGray : peak ? 8'h00 : SW[4] ? aGray : SW[3] ? corn : SW[2]?(xgrad+8'd128):(ygrad+8'd128);

//TODO: uncomment
//reg	a_peak,b_peak;
//reg	[12:0]	a_max,a_argmaxX,a_argmaxXold,a_argmaxY,a_argmaxYold;
//reg	[12:0]	b_max,b_argmaxX,b_argmaxXold,b_argmaxY,b_argmaxYold;
//wire	[7:0]	a_reddest,b_reddest;
//assign a_reddest	=	raw_aR;
//assign b_reddest	=	raw_bR;
////assign LEDR = a_argmaxYold;
//always @(posedge VGA_CLK) begin//TODO: get proper numbers i.e. x1 instead of x2
//	if(x1==0 && y1==45) begin
//		a_max	<=	0;
//		a_argmaxXold	<=	a_argmaxX;
//		a_argmaxX		<= 0;
//		a_argmaxYold	<=	a_argmaxY;
//		a_argmaxY		<=	0;
//		b_max	<=	0;
//		b_argmaxXold	<=	b_argmaxX;
//		b_argmaxX		<= 0;
//		b_argmaxYold	<=	b_argmaxY;
//		b_argmaxY		<=	0;
//	end else begin
//		if(a_reddest>=a_max) begin
//			a_max			<=	a_reddest;
//			a_argmaxX	<=	x1;
//			a_argmaxY	<=	y1;
//		end
//		if(b_reddest>=b_max) begin
//			b_max			<=	b_reddest;
//			b_argmaxX	<=	x1;
//			b_argmaxY	<=	y1;
//		end
//	end
//	if(x1==a_argmaxXold && y1==a_argmaxYold)
//		a_peak=1'b1;
//	else
//		a_peak=1'b0;
//	if(x1==b_argmaxXold && y1==b_argmaxYold)
//		b_peak=1'b1;
//	else
//		b_peak=1'b0;
//end

//always @(*) begin
//	case(SW[1]?a_argmaxXold[3:0]:b_argmaxXold[3:0])
//		4'b0000: HEX0 = 8'b11000000;
//		4'b0001: HEX0 = 8'b11111001;
//		4'b0010: HEX0 = 8'b10100100;
//		4'b0011: HEX0 = 8'b10110000;
//		4'b0100: HEX0 = 8'b10011001;
//		4'b0101: HEX0 = 8'b10010010;
//		4'b0110: HEX0 = 8'b10000010;
//		4'b0111: HEX0 = 8'b11111000;
//		4'b1000: HEX0 = 8'b10000000;
//		4'b1001: HEX0 = 8'b10010000;
//		4'b1010: HEX0 = 8'b10001000;
//		4'b1011: HEX0 = 8'b10000011;
//		4'b1100: HEX0 = 8'b11000110;
//		4'b1101: HEX0 = 8'b10100001;
//		4'b1110: HEX0 = 8'b10000110;
//		4'b1111: HEX0 = 8'b10001110;
//		default: HEX0 = 8'b11111111;
//	endcase
//	case(SW[1]?a_argmaxXold[7:4]:b_argmaxXold[7:4])
//		4'b0000: HEX1 = 8'b11000000;
//		4'b0001: HEX1 = 8'b11111001;
//		4'b0010: HEX1 = 8'b10100100;
//		4'b0011: HEX1 = 8'b10110000;
//		4'b0100: HEX1 = 8'b10011001;
//		4'b0101: HEX1 = 8'b10010010;
//		4'b0110: HEX1 = 8'b10000010;
//		4'b0111: HEX1 = 8'b11111000;
//		4'b1000: HEX1 = 8'b10000000;
//		4'b1001: HEX1 = 8'b10010000;
//		4'b1010: HEX1 = 8'b10001000;
//		4'b1011: HEX1 = 8'b10000011;
//		4'b1100: HEX1 = 8'b11000110;
//		4'b1101: HEX1 = 8'b10100001;
//		4'b1110: HEX1 = 8'b10000110;
//		4'b1111: HEX1 = 8'b10001110;
//		default: HEX1 = 8'b11111111;
//	endcase
//	case(SW[1]?a_argmaxXold[11:8]:b_argmaxXold[11:8])
//		4'b0000: HEX2 = 8'b11000000;
//		4'b0001: HEX2 = 8'b11111001;
//		4'b0010: HEX2 = 8'b10100100;
//		4'b0011: HEX2 = 8'b10110000;
//		4'b0100: HEX2 = 8'b10011001;
//		4'b0101: HEX2 = 8'b10010010;
//		4'b0110: HEX2 = 8'b10000010;
//		4'b0111: HEX2 = 8'b11111000;
//		4'b1000: HEX2 = 8'b10000000;
//		4'b1001: HEX2 = 8'b10010000;
//		4'b1010: HEX2 = 8'b10001000;
//		4'b1011: HEX2 = 8'b10000011;
//		4'b1100: HEX2 = 8'b11000110;
//		4'b1101: HEX2 = 8'b10100001;
//		4'b1110: HEX2 = 8'b10000110;
//		4'b1111: HEX2 = 8'b10001110;
//		default: HEX2 = 8'b11111111;
//	endcase
//	
//	case(SW[1]?a_argmaxYold[3:0]:b_argmaxYold[3:0])
//		4'b0000: HEX3 = 8'b11000000;
//		4'b0001: HEX3 = 8'b11111001;
//		4'b0010: HEX3 = 8'b10100100;
//		4'b0011: HEX3 = 8'b10110000;
//		4'b0100: HEX3 = 8'b10011001;
//		4'b0101: HEX3 = 8'b10010010;
//		4'b0110: HEX3 = 8'b10000010;
//		4'b0111: HEX3 = 8'b11111000;
//		4'b1000: HEX3 = 8'b10000000;
//		4'b1001: HEX3 = 8'b10010000;
//		4'b1010: HEX3 = 8'b10001000;
//		4'b1011: HEX3 = 8'b10000011;
//		4'b1100: HEX3 = 8'b11000110;
//		4'b1101: HEX3 = 8'b10100001;
//		4'b1110: HEX3 = 8'b10000110;
//		4'b1111: HEX3 = 8'b10001110;
//		default: HEX3 = 8'b11111111;
//	endcase
//	case(SW[1]?a_argmaxYold[7:4]:b_argmaxYold[7:4])
//		4'b0000: HEX4 = 8'b11000000;
//		4'b0001: HEX4 = 8'b11111001;
//		4'b0010: HEX4 = 8'b10100100;
//		4'b0011: HEX4 = 8'b10110000;
//		4'b0100: HEX4 = 8'b10011001;
//		4'b0101: HEX4 = 8'b10010010;
//		4'b0110: HEX4 = 8'b10000010;
//		4'b0111: HEX4 = 8'b11111000;
//		4'b1000: HEX4 = 8'b10000000;
//		4'b1001: HEX4 = 8'b10010000;
//		4'b1010: HEX4 = 8'b10001000;
//		4'b1011: HEX4 = 8'b10000011;
//		4'b1100: HEX4 = 8'b11000110;
//		4'b1101: HEX4 = 8'b10100001;
//		4'b1110: HEX4 = 8'b10000110;
//		4'b1111: HEX4 = 8'b10001110;
//		default: HEX4 = 8'b11111111;
//	endcase
//	case(SW[1]?a_argmaxYold[11:8]:b_argmaxYold[11:8])
//		4'b0000: HEX5 = 8'b11000000;
//		4'b0001: HEX5 = 8'b11111001;
//		4'b0010: HEX5 = 8'b10100100;
//		4'b0011: HEX5 = 8'b10110000;
//		4'b0100: HEX5 = 8'b10011001;
//		4'b0101: HEX5 = 8'b10010010;
//		4'b0110: HEX5 = 8'b10000010;
//		4'b0111: HEX5 = 8'b11111000;
//		4'b1000: HEX5 = 8'b10000000;
//		4'b1001: HEX5 = 8'b10010000;
//		4'b1010: HEX5 = 8'b10001000;
//		4'b1011: HEX5 = 8'b10000011;
//		4'b1100: HEX5 = 8'b11000110;
//		4'b1101: HEX5 = 8'b10100001;
//		4'b1110: HEX5 = 8'b10000110;
//		4'b1111: HEX5 = 8'b10001110;
//		default: HEX5 = 8'b11111111;
//	endcase
//end

endmodule
